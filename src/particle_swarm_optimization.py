import random

#Function to initialise the PSO particles.
def init_pso(data, feat_num, max_k, pop_size, threshold):
    
    particles = []
    #Particle length is calculated based on the maximum K-value given by the user and the number of features in each data-point.
    particle_len = max_k + (max_k * feat_num)
    data_len = len(data)    
    #Iterating over the population of particles.
    for i in xrange(0, pop_size):
        temp_particle = []
        #For each of the first k elements:
        for j in xrange(0, max_k):
            #A random number between 0 and 1 is generated to serve as the cluster activation value.
            temp_particle.append(random.random())
        counter = 0
        #A set is initialized to store the indexes of the data-points.
        rand_set = set()
        #Iterating from the k-th element to the end of the particle
        for j in xrange(max_k, particle_len):
            #If it's the first instance of the corresponding cluster.
            if (counter == 0):
                #A random index is selected
                rand = random.randint(0, (data_len - 1))
                #If the index is in the set already, random indexes are continually generated until one is found that is not in the set.
                while rand in rand_set:
                    rand = random.randint(0, (data_len - 1))
                #The data-point of that index is saved as a center, the data-point's index is added to the set.
                center = data[rand]
                rand_set.add(rand)
            temp_particle.append(center[counter])
            counter = counter + 1
            #When the number of features is reached, the counter is reset.
            if (counter == feat_num):
                counter = 0
        #The new particle is checked for validity.
        temp_particle = check_particle(temp_particle, threshold, max_k)
        #The particle is appended into the array.
        particles.append(temp_particle)
    return particles

#Function to check if a particle is valid.
def check_particle(particle, threshold, max_k):
    k = 0
    #Checking that a minimum of 2 activation values are greater than the user-input threshold.
    for i in xrange(0, max_k):
        if particle[i] >= threshold:
            k += 1
    #If there are not 2 activation values greater than threshold
    if (k < 2):
        #2 active thresholds are generated and inserted randomly into the activation section of the chromosome.
        for l in xrange(0, 2):
            rand_thresh = random.uniform(threshold, 1)
            rand_loc = random.randint(0, (max_k - 1))
            particle[rand_loc] = rand_thresh
    return particle

#Function to find the maximum and minimum values allowed for a particular element.
def find_max_min_ele(data, ele_ind):
    data_len = len(data)
    max_ele = 0
    min_ele = 99999
    #Iterates over the entire dataset.
    for i in xrange(0, data_len):
        if data[i][ele_ind] > max_ele:
            max_ele = data[i][ele_ind]
        if data[i][ele_ind] < min_ele:
            min_ele = data[i][ele_ind]
    #Returns the maximum and minimum values for the particular element.
    return {"max_ele":max_ele, "min_ele":min_ele}

#Function to initialise particle velocities.
def init_velocities(data, feat_num, max_k, chrom_len, pop_size):
    velocities = []

    for i in xrange(0, pop_size):
        temp_vel = []

        #For the activation section of the particle, the velocity is generated by halving a random number between 0 and 1.
        for j in xrange(0, max_k):
            temp_vel.append(0.5 * random.random())

        #For the other elements:
        for j in xrange(0, max_k):
            for k in xrange(0, feat_num):
                #A random number is generated to determine whether velocity will be positive or negative.
                plus_minus = random.random()
                #The current element's maximum and minimum values are calculated.
                elements = find_max_min_ele(data, k)
                max_ele = elements.get("max_ele")
                min_ele = elements.get("min_ele")
                #The velocity is generated by multiplying a random value between min and max by 0.4
                if plus_minus > 0.5:
                    temp_vel.append(0.4 * random.uniform(min_ele, max_ele))
                else:
                    temp_vel.append((0.4 * random.uniform(min_ele, max_ele)) * -1)
        velocities.append(temp_vel)
    return velocities

#Function to reinitialize a particle.
def reinit_particle(particle, data, feat_num, max_k, threshold, debug_flag):
    if (debug_flag == True):
        print "Invalid centroid detected, reinitializing particle..."
    particle_len = len(particle)
    data_len = len(data)
    temp_particle = []
    #The activation section of the particle is reinitialized with random numbers between 0 and 1.
    for i in xrange(0, max_k):
        temp_particle.append(random.random())
    counter = 0
    #A set is initialized to store the indexes of the data-points.
    rand_set = set()
    #iterating over the rest of the particle elements.
    for i in xrange(max_k, particle_len):
        #If its the first instance of this cluster:
        if (counter == 0):
            #random data-points are generated until one is found that's not in the set.
            rand = random.randint(0, (data_len - 1))
            while rand in rand_set:
                rand = random.randint(0, (data_len - 1))
            center = data[rand]
            rand_set.add(rand)
        temp_particle.append(center[counter])
        counter = counter + 1
        #When the number of features is reached, the counter is reset.
        if (counter == feat_num):
            counter = 0
    particle = temp_particle
    #The particle is checked for validity before being returned.
    particle = check_particle(particle, threshold, max_k)
    return particle 

#Function to decode the centroid from a particle.
def get_center(particles, max_k, threshold, feat_num): 
    centers = []
    #Iterating over the activation section.
    for i in xrange(0, max_k):
        temp_center = []
        #If the activation value is greater than the threshold:
        if particles[i] >= threshold:
            #The corresponding centroid's first and last elements are calculated.
            first_element = max_k + (i * feat_num)
            last_element = first_element + feat_num
            #Iterating over the corresponding centroid:
            for j in xrange(first_element, last_element):
                temp_center.append(particles[j])
            #Appending the centroid into the centroic array.
            centers.append(temp_center)
    return centers

#Function to update the particle's position.
def update_position(particle, velocity, max_k, feat_num, data, debug_flag):
    if (debug_flag == True):
        print "particle before:", particle
        print "velocity:", velocity
    particle_len = len(particle)
    #Iterating over the length of the particle.
    for i in xrange(0, particle_len):
        #Applying the particle's velocity.
        particle[i] = particle[i] + velocity[i]
    #Checking the particle has remained within the solution space.
    particle = check_position(particle, max_k, feat_num, data)
    if (debug_flag == True):
        print "particle after:", particle
    return particle
    
#Function to check a particle's position.
def check_position(particle, max_k, feat_num, data):
    #Resetting any activation values that have strayed out of bounds.
    for i in xrange(0, max_k):
        if (particle[i] > 1.0):
            particle[i] = 1.0
        if (particle[i] < 0.0):
            particle[i] = 0.0
        #Calculating centroid's first and last elements.
        first_element = max_k + (i * feat_num)
        last_element = first_element + feat_num
        counter = 0
        #Iterating over the centroid.
        for j in xrange(first_element, last_element):
            #Calculating the maximum and minimum allowed values.
            max_min = find_max_min_ele(data, counter)
            max_ele = max_min.get("max_ele")
            min_ele = max_min.get("min_ele")
            #Checking if the centroid has strayed outside of these values, and resetting them.
            if (particle[j] > max_ele):
                particle[j] = max_ele
            if (particle[j] < min_ele):
                particle[j] = min_ele
            counter = counter + 1
    return particle

#Function to update the particle's velocity/
def update_velocity(omega_min, omega_max, particle, velocity, weight, p_best, g_best, debug_flag):
    if (debug_flag == True):
        print "\nUpdating velocity..."
    #Two omega values are randomly generated from the range provided by the user.
    omega_1 = random.uniform(omega_min, omega_max)
    omega_2 = random.uniform(omega_min, omega_max)
    particle_len = len(particle)
    if (debug_flag == True):
        print "Velocity before:", velocity
    for i in xrange(0, particle_len):
        #The new velocity is based on the old velocity (weighted by the user), the particle's personal best and the swarm's global best.
        velocity[i] = (weight * velocity[i]) + (omega_1 * (p_best[i] - particle[i])) + (omega_2 * (g_best[i] - particle[i]))
    if (debug_flag == True):
        print "Velocity after:", velocity
    return velocity

    
    